# 作业：面向葫芦娃编程

## UML类图

![UML类图](http://www.plantuml.com/plantuml/png/nLN1Zjem4BtdAqRR2zi2slQs4ggskrhrKfLMowtgOP8CIRI9dHqxj8ZoxxKn0HD30uTgaK31VlFclV5uSgSqicwgCgenUSQCuAecLkCoMOxpfcokuCtjpUFZxGsi8e12QE8v9WHFaZN69Krc7pSx00jPf5391Stau1CpBhyKIjljh5YG-DvGGqDB02Kg_KsgGXTINEz3uoOsV9RtLBW7VccAvBaFkpPVZ9LcJ3Ga9gtQo2QUp81-QnAfydsqHjwjsg3rHSh2m7wL04xdLjwKavmiXQtDELf73xAgqU0bM-Pazyy9Ei8tE1MnzN2PupDjEgtzOAz9QAxT4nTPhgyFolIGIoQPCTRvigTA_zUK9mbBZ57bzonrJjmUZpKG5wppAQV4Rkr9So4o45YHozU97NY08HmoR1NQnOpq_Mvzu4iNJHKJJ-TpVpMycfsquHdK_YKDYzZBr5_I_b1NGjUbLdwtpflVBV82WVqpQNI-v9xU7K84tgVhm3oRk5ZAab30NF8lvDI5Bp11aIoxK-8peqXhR7jiIxI_rn3ldntas5m9R4YtyLg7xJkqSQszbT96ThBUL4HqA3eGTtD-_8JORN_5YbG7ymyvBrQ9yx23kxk3XHZio94pTQWtE89sy7ZD6xRk-o44QnySiV-gFHZOaTbovmIJFwFHiJT61n4CImTmGz90ncC8YzgssDjZAG94O3y2JxNB4M9y5M6QGEW9Artn5dWo6KYpUThjnEYqi0YEfDhlhgCx4cbJbNy1)

## 实现方法

在修改后的葫芦娃排序程序中，首先有接口Sortable，实现这个接口的类的对象组成的队列，需要可以用编排和协同两种形式进行排序，该接口包含以下行为：

1. 移动到队列中的指定位置上，队列以ArrayList数据结构表示，抽象为方法moveTo
2. 在队列中进行协同排序，包括冒泡排序和快速排序，抽象为方法bubbleSort和quickSort

而葫芦娃类CalabashBrother则实现了该接口，葫芦娃的状态包括自己的排行和名字，抽象为属性birthOrder和name，在使用构造器创建一个葫芦娃类对象的时候，即需要为这两个属性赋值；葫芦娃类除了接口Sortable的方法以外，还有用以辅助进行冒泡排序和快速排序的方法compareTo、bubbleSort和quickSort，以及由行为抽象得到的方法：

1. 给出自己的排行，抽象为getBirthOrder，这个方法会被一个Comparator用到
2. 进行报数，即输出自己的名字，抽象为numberOff

Sorter类是对队列进行排序的类，它有bubbleSort和quickSort两个方法，代表不管是以编排还是协同进行排序，都需要实现冒泡排序和快速排序两种算法；由于在指定排序形式前无法给出算法的具体实现，因此它是一个虚基类。此外，Sorter类使用了泛型技术，它要求参数类型实现了Sortable接口。OrchestrationSorter类和ChoreographySorter类是两个继承自该虚基类的子类，分别在编排和协同形式下实现了对队列的冒泡排序和快速排序。其中OrchestrationSorter类在构造时需要提供一个Comparator，用以比较两个Sortable的大小，这样设计是为了体现编排的原则，即尽可能地减少要被排序的对象间的直接交互，而将比较两个对象的工作交由Sorter。

BrotherComparator类是上述所需要用到的类，它实现了对于两个葫芦娃对象的比较，通过调用葫芦娃的getBirthOrder方法，这一方法可以很简单地完成。

Grandpa类是对葫芦娃们的爷爷的抽象，在进行编排形式的排序时，程序会实例化该类的一个对象，而Grandpa的属性包括：

1. 一个BrotherComparator类对象，表示爷爷具有对葫芦娃们进行比较的能力
2. 一个OrchestrationSorter类对象，以葫芦娃为参数类型，表示爷爷能指挥葫芦娃们进行编排形式的排序，从UML类图可以看出，调用爷爷的排序方法实际上将会委托这个OrchestrationSorter来完成。

Grandpa类的方法即对葫芦娃组成的队列进行冒泡排序和快速排序。

Sort类是实现了main方法的程序的入口，它构建问题的初始情景，让葫芦娃们随机排成一列，进行排序，最后让葫芦娃从第一个到最后一个报数。

## 特性和语言机制

### 特性

封装体现在各个类中的访问控制中，比如CalabashBrother类对辅助排序的方法bubbleSort、quickSort等进行了封装，在修改这些方法时就不用担心会影响到从外部调用它们的用户了；继承体现在OrchestrationSorter类和ChoreographySorter类对Sorter类的继承上；在程序中，在引用OrchestrationSorter类和ChoreographySorter类的对象时，统一都使用了Sorter类型的引用，表示创建完成后，我们就不必再关心它们到底是哪一种分类器，程序运行时调用bubbleSort和quickSort方法时，会自动绑定对应子类的相应方法实际完成排序，这就是多态的体现。

### 语言机制

1. 接口：Sortable接口使用到了接口机制。
2. 构造器：CalabashBrother和OrchestrationSorter类都具有自定义的构造器，而没有使用Java的默认构造函数。
3. 静态变量和静态块：在程序入口所在的Sort类中，问题的初始情景的构建(即有七个随机排列的葫芦娃)是在main方法之前完成的，这里利用的就是静态变量和静态块机制，静态变量包括葫芦娃的数量，各个葫芦娃的名字，以及葫芦娃组成的队列，它们都是在静态块中完成初始化的。
4. 整个程序的类都位于一个名为"pers.lcy.hulu"的包中，pers表示这是一个独立完成的个人项目，lcy是我的名字首写，hulu则是项目的名字；包机制保证了如果有其他项目中存在Sorter这样名字较容易被用到的类，不会与我的Sorter类发生冲突。虽然没有用到import，也体现了包机制的作用。
5. 修饰符出现在程序的各个位置，如类的修饰符、成员变量的修饰符、方法的修饰符等，这是我们使用得最频繁的机制了。

## 程序的运行方法

将各个源代码文件编译完成后，在README.md所在的根目录下输入以下命令即可运行程序：

```bash
java pers.lcy.hulu.Sort Orchestration/Choreography BubbleSort/QuickSort
```

第一个参数代表使用编排还是协同形式的排序，第二个参数则表示使用冒泡排序还是快速排序。