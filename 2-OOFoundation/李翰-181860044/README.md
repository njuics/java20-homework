## 面向葫芦娃编程

#### Orchestration形式

Orchestration形式下由葫芦娃的爷爷指挥葫芦娃们行动（排序），则需要两个类表示相应对象——类`Grandpa`表示爷爷，类`HuLu`表示葫芦娃们。

- `HuLu`类中有两个私有属性分别表示名字（==name==）和排序的依据（==rank==，最小的排在最前面），相应的一个用于外部获取==rank==值的方法==getRank==，以及用于报数的函数==sounfOff==。

- 爷爷需要进行指挥，故其类中应有一个方法可以对任意两个葫芦娃进行比较以确定其位置（==cmp==）、以及另一个方法指挥两个葫芦娃是否需要互换位置（==command==）。

从而排序的过程即为：

1. **爷爷**（执行者）**比较**（执行动作）某两个葫芦娃的==rank==值
2. **爷爷**（执行者）依据比较结果**指挥**（执行动作）相应的葫芦娃调换位置
3. 上述操作执行若干次后完成排队

代码中采用的是*冒泡排序*，也可替换为其他*基于比较*的排序算法，只需更改`Orchestration`类中的==sort==方法即可（其他类无需改动）。



#### Choreography形式

Choreography形式下由葫芦娃之间相互协作，完成排序过程，则只需要一个类表示相应对象——类`HuLu`表示葫芦娃们。

- 在上述`Orchestration形式`的基础上，由于是葫芦娃之间协作，故而`HuLu`类中需要有相应的方法使得每个葫芦娃：①都能获得其他葫芦娃的==rank==值以便判断位置（==getOtherRank==）；②能与其他葫芦娃互换位置(==exchangePos==)。

从而排序的过程即为：

1. 某个**葫芦娃A**（执行者）**获取**（执行动作）另一个葫芦娃B的==rank==值，并进行比较
2. **葫芦娃A**（执行者）依据比较结果决定是否要与葫芦娃B**互换位置**（执行动作）
3. 上述操作执行若干次后完成排队

同样的，代码中采用的是*冒泡排序*，也可替换为其他*基于比较*的排序算法，只需更改`Choreography`类中的==sort==方法即可（其他类无需改动）。