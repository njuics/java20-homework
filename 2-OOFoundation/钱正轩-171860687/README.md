# HW2

171860687 钱正轩

## 类的设计

在这次实验中设计了类 `HuLuWa` 来抽象葫芦娃，葫芦娃有自己的名字（用 enum 实现），也有两个对 `HuLuWa` 的引用，分别表示左右两侧的葫芦娃，为每个属性设置了 getter 和 setter，除此之外还实现了 `swap` 方法用于和某个葫芦娃交换位置。除此之外还重载了 `toString` 和 `compareTo` 以及 `equals`

基于 `HuLuWa` 类设计了 `HuLuBrothers` 类，代表葫芦兄弟，由于葫芦兄弟是唯一的，故使用了单例模式，其中有私有字段，存储了七个葫芦娃的实例，实现方式为 `ArrayList`，向外提供的接口有 `getHuLuBrothers` 用于提供实例，`shuffle` 用于打乱葫芦娃的顺序，`swap` 用于指定两个葫芦娃交换位置，`compare` 用于比较两个好葫芦娃的顺序，还有一些打印函数和排序函数。这里的打印是基于葫芦娃的邻接关系而不是容器内的顺序，因为提供的排序方法不是都会改变容器内的顺序。

## 排序

### 使用算法排序

使用算法排序是基于 `HuLuBrothers` 的 `sortByAlgorithm` 方法实现的，这个方法接受一个泛型排序函数作为输入，函数的返回值为空，参数是一个 `List<T>` 容器，要求 `T` 实现了 `Comparable` 接口，具体的定义如下

```java
public interface SortFunc {
    <T extends Comparable<T>> void sort(List<T> list);
}
```

`HuLuBrothers` 自身提供了一个默认的排序函数，使用插入排序算法，使用默认函数只需要调用 `sortByAlgorithm` 的无参数的重载版本即可

也可以使用用户自定义的函数，在示例中使用的是自己实现的快速排序算法

这种排序方法直接排序容器内的葫芦娃，思想上比较接近结构化程序设计

### 使用编排的方式排序

使用编排的方式排序，思想主要是使用一个外部对象来调度葫芦娃排序，这里设计了一个 `Grandpa` 类用于调度，其在初始化时获取一个 `HuLuBrothers` 的实例，然后使用 `HuLuBrothers` 提供的接口进行排序，这里只用到了三个接口 `swap`，`compare`，`getNumber` 分别用于交换，比较，获取葫芦娃总数，这三个基本操作足以实现绝大部分基于比较的排序方法，而 `Grandpa` 并不需要关注葫芦娃实例具体是怎么组织的。排序的过程就是 `Grandpa` 和 `HuLuBrothers` 之间进行信息的交换，而 `HuLuBrothers` 与 `HuLuWa` 之间进行信息的交换，比较符合面向对象的编程思想。

在具体实现中同样使用了快速排序算法

### 使用协同的方式排序

使用协同的方式排序，思想主要是葫芦娃互相协作完成排序，由于葫芦娃并不知道自己所处的容器，故这种排序也不会改变容器中葫芦娃的顺序，只是改变了邻接关系。7 个葫芦娃依次行动，每个葫芦娃检查自己左边的葫芦娃，只要不是空且比自己序数更大，就和左边的葫芦娃交换，同理只要右边的葫芦娃不是空且比自己序数更小，就和右边的葫芦娃交换，重复此过程直到自己和左右两边的葫芦娃构成升序，然后轮到下一个葫芦娃行动，这种排序方式是可靠的

* 后行动的葫芦娃不会破坏之前葫芦娃的升序关系，考虑之前已经行动过的葫芦娃 `i`，如果当前行动的葫芦娃为 `j`，如果破坏了升序关系则显然 `i,j` 相邻，wolp. 设 `j` 序数比 `i` 大且位于 `i` 左边，则在 `j` 破坏了 `i` 的升序关系的同时 `j` 本身的升序关系也没有满足，`j` 会继续行动，和 `i` 交换，不管是和 `i` 在右边相邻还是交换到更右边，`i` 的升序关系都得到了满足
* 所有葫芦娃都行动后所有葫芦娃都和相邻的两个葫芦娃满足升序关系，显然葫芦娃的序列不存在逆序对，排序完成

这种协同排序是葫芦娃之间互相合作完成的，不需要外界进行调度，通过葫芦娃互相交换信息实现，也比较符合面向对象编程的思想

## 运行

使用

```
javac HuLu.java
```

编译，使用

```
java HuLu
```

运行