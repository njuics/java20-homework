# 作业：面向葫芦娃编程

在这个问题中，根据采用的排序形式的不同，对问题进行抽象得到的对象种类、它们的行为也不同，因此我选择将两种排序方法在两个不同的程序中实现，下面将说明这两个程序中，我用面向对象编程思想解决问题的方法。

## 编排（Orchestration）

在编排形式的排序中，存在葫芦娃（CalabashBrother），老爷爷（Grandpa）和队列（Queue）三个类的对象，其中，

***

队列类是对葫芦娃们组成的队列的抽象，它具有以下的属性：

1. 队列当前的状态

并且具有以下方法：

1. 返回队列的长度
2. 返回给定位置上的葫芦娃
3. 改变给定位置上的葫芦娃，表示队列的状态发生变化

***

葫芦娃类具有以下属性：

1. 排行，表示葫芦娃在七兄弟中的排行
2. 名称，表示每个葫芦娃的名字，比如“老大”、“老二”等

对葫芦娃的行为抽象得到的方法则包括：

1. 返回自己的排行
2. 进行报数，即将自己的名称输出到标准输出
3. 在给定的队列中移动到给定位置上，通过调用队列类的方法3实现

***

老爷爷类是编排形式的排序中的“控制器”，它没有属性，方法包括：

1. 比较两个葫芦娃的排行，通过调用葫芦娃类的方法1实现
2. 指挥给定队列中的葫芦娃按照排行从大到小进行排序，这一步可以是冒泡排序，也可以是快速排序。在编排形式的排序中，老爷爷是唯一知道整个排序算法应该怎么进行的对象，它负责调用各个葫芦娃对象的方法，获取它们的排行，对它们进行比较，并且在需要的时候让葫芦娃移动到队列中的指定位置上。也正因为老爷爷知道整个算法的全貌，这个排序算法非常好写，也很容易替换，不管是冒泡排序还是快速排序，都只要像在一个普通的数组上排序一样进行就可以了。只需要注意，在基于面向对象的思想下，我们不会直接将队列的某一项设置为某个葫芦娃，而是让葫芦娃“移动”到队列的某个位置；同时，在编排的思想下，任意两个葫芦娃之间都不会直接进行交互，两个葫芦娃之间的比较是由老爷爷完成的。

***

编排程序中还有另一个类Orchestration，这个类包括了程序的入口（main方法），在main方法中，它首先构建出问题的初始情景，即有一个老爷爷，还有七个随机排列的葫芦娃；随后，老爷爷会指挥七个葫芦娃进行排序；排完序后，葫芦娃们会从第一个到最后一个依次报数。

运行编排程序时，可以通过传入不同的命令行参数，让老爷爷使用不同的算法指挥葫芦娃们进行排序，如果要使用冒泡算法，输入：

```bash
java Orchestration BubbleSort
```

如果要使用快速排序，输入：

```bash
java Orchestration QuickSort
```

## 协同（Choreography）

在协同形式的排序中，只存在葫芦娃（CalabashBrother）和队列（Queue）两个类的对象，并且它们的行为和编排形式的排序中的有所不同，

***

队列类的其他属性和方法没有改变，但有一个新的方法

4. 指定一个葫芦娃，返回这个葫芦娃在队列中的位置

***

葫芦娃类仍然具有排行、名称两个属性，但它的方法变为：

1. 与另一个葫芦娃比较排行
2. 在给定的队列中移动到给定位置上
3. 在给定的队列中与其他葫芦娃进行协同，完成排序（冒泡排序或快速排序），我们使用带注释的代码来说明排序如何实现：

```java
public void bubbleSort(Queue givenQueue, int lastPosition) {
        // 获取自己的位置
        int thisPosition = givenQueue.getPosition(this);

        // 如果自己不在可移动到的最后一个位置，并且自己比下一个位置的葫芦娃排行靠后，则和它交换位置
        CalabashBrother nextBrother = null;
        while(thisPosition < lastPosition && 
                compareTo(nextBrother = givenQueue.getBrother(thisPosition + 1)) > 0) {
            moveTo(givenQueue, thisPosition + 1);
            nextBrother.moveTo(givenQueue, thisPosition);
            thisPosition++;
        }

        // 如果循环结束后仍不在可移动到的最后一个位置，则向下一个葫芦娃传递消息，让它接替排序过程
        // 如果已经在最后一个位置，则当前趟结束，向队首的葫芦娃传递消息，让它开始下一趟排序
        if(thisPosition < lastPosition) {
            nextBrother.bubbleSort(givenQueue, lastPosition);
        } else if(lastPosition > 0) {
            givenQueue.getBrother(0).bubbleSort(givenQueue, lastPosition - 1);
        }
    }
```

冒泡排序的每一趟都结束于不同的位置，比如第一趟在最后比较的是element[length - 2]和element[length - 1]，而第二趟在最后比较的是element[length - 3]和element[length -2]，直到最后一趟只需要比较element[0]和element[1]；我们用lastPosition这一参数表示当前这一趟在哪里结束（可移动到的最后一个位置）。算法的开始，葫芦娃获取自己当前的位置，如果自己不在可移动到的最后一个位置，并且自己比下一个位置的葫芦娃排行靠后，则和它交换位置，并且循环进行这一行为。如果循环结束后仍不在可移动到的最后一个位置，则向下一个葫芦娃传递消息，让它接替排序过程；如果已经在最后一个位置，则当前趟结束，向队首的葫芦娃传递消息，让它开始下一趟排序。通过这样的算法实现，在初始情景下只需要调用一次队首葫芦娃的bubbleSort方法，就能在不需要从外部向葫芦娃们传递任何消息的情况下完成排序，这体现的是一种去中心化的思想。

快速排序则更难写一些，并且各个葫芦娃之间消息的传递也更加复杂，受篇幅所限不在这里说明，如果有兴趣可以查看Choreography.java文件中CalabashBrother类的quickSort方法，我也做了简单的注释。从这里也可以看出，在协同中替换排序算法要更有难度。

***

协同程序中的入口位于类Choreography的main方法。在main方法中，它同样首先构建出问题的初始情景，有七个随机排列的葫芦娃；随后让队首的葫芦娃开始协同排序（如果每个葫芦娃都是一个单独的进程，则可以让它们检查自己的位置，在队首的葫芦娃自动开始排序，这样连初始的消息也可以省去）；排序完成后，葫芦娃们从第一个到最后一个依次报数。

运行编排程序时，可以通过传入不同的命令行参数，让葫芦娃们使用不同的算法进行协同排序，如果要使用冒泡算法，输入：

```bash
java Choreography bubbleSort
```

如果要使用快速排序，输入：

```bash
java Choreography quickSort
```

