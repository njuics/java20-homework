# 类加载与反射

作业实现了Base64ClassLoader类，其findClass(String name)方法能够从文件中读取并解析Base64编码的Java字节码，返回字节码所定义的Java类。

findClass方法遵循其在父类中的语义，将需要加载的类的Binary name作为参数，在Classpath下寻找对应的.b64文件，调用loadBase64FromFile(String filename)方法，将Base64编码作为字符串从文件中读取出，再调用decodeBase64(String base64)方法，将Base64编码解码为字节序列，最后调用defineClass(String name,  byte[] b, int off, int len)方法将字节序列转化为Class类的对象并返回。

通过上述实现方法，Base64ClassLoader除了本次作业中的"Monster"类，也能用于加载其他以Base64编码的Java类。实现时也考虑过不需要类名，而是从给定的文件中加载Base64编码类的实现方法，但是如果这样做，Base64ClassLoader类就不应重写原有的findClass方法，而应该提供新的public接口供外部直接调用，以防止改变findClass方法的语义。这样一来，新的ClassLoader类将完全不按照原有的Class.forName-ClassLoader.loadClass-ClassLoader.findClass调用链进行类的加载，其实除了defineClass方法外，和原有的ClassLoader类已经没有太大的关系了。为了尽可能利用原有的类加载机制，实现中还是选择通过类名进行加载。

Reflection类的main方法完成类的加载和对反射机制的调用。首先调用Class.forName(String name, boolean initialize, ClassLoader loader)方法，指定Base64ClassLoader的一个实例作为加载器，加载Base64编码的类，获得Class对象。随后调用其getDeclaredConstructor方法获取Constructor，利用Constructor实例化一个该类的对象（这里直接获取并使用参数类型为String, int, int的构造器，如果事先不知道参数的类型，也可以使用Constructor的getParameterCount和getParameterTypes方法，再相应地提供参数，但是实现比较困难）。通过反射机制找出该类所有的方法和属性时，可以先调用getDeclaredMethods和getDeclaredFields方法获取该类自身定义的所有方法和属性，再沿继承链向上，获取其直接父类和各间接父类的public和protected方法和属性。

